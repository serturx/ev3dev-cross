"""
Browsing the origin of code generated by yupp lexical preprocessor.

http://github.com/in4lio/yupp/

Copyright (c) 2015-16 Vitaly Kravtsov (in4lio@gmail.com)
"""

__version__ = 1.4

import os
import json
import sublime, sublime_plugin

STATE_NO_BROWSE = 0
STATE_FRUIT     = 1
STATE_ORIGIN    = 2
STATE_CHECK_RAW = 3

file_state = {}

file_data  = {}
file_jump  = {}
file_mtime = {}  # time of last modification

#   ---------------------------------------------------------------------------
def _bisect( a, x ):
    """
    Modified 'bisect_right' from Python standard library.
    """
    hi = len( a )
    lo = 0
    while lo < hi:
        mid = ( lo + hi ) // 2
        if x < a[ mid ][ 0 ]:
            hi = mid
        else:
            lo = mid + 1
    return lo

#   ---------------------------------------------------------------------------
def search_file( fruit, dirs, inx ):
    paths = file_data[ fruit ][ 'paths' ]
    if paths[ inx ]:
        return paths[ inx ]

    fn = file_data[ fruit ][ 'files' ][ inx ]
    if os.path.isfile( fn ):
        p = os.path.abspath( fn )
        paths[ inx ] = p
        return p

    for d in dirs:
        p = os.path.normpath( os.path.join( d, fn ))
        if os.path.isfile( p ):
            paths[ inx ] = p
            return p

    for d in dirs:
        p = os.path.normpath( os.path.join( d, os.path.basename( fn )))
        if os.path.isfile( p ):
            paths[ inx ] = p
            return p

    return ''

#   ---------------------------------------------------------------------------
def open_file( fn ):
    # check browse (*.json)
    fn_json = fn + '.json'
    if os.path.isfile( fn_json ):
        # load browse
        with open( fn_json ) as f:
            file_data[ fn ] = json.load( f )

        # search for original files in fruit's directory
        l_files = len( file_data[ fn ][ 'files' ])
        dirs = [ os.path.dirname( fn )]
        file_data[ fn ][ 'paths' ] = [ '' ] * l_files
        for i in xrange( l_files ):
            search_file( fn, dirs, i )

        file_state[ fn ] = STATE_FRUIT
        file_mtime[ fn ] = os.path.getmtime( fn )

        # check row (*.txt)
        if os.path.isfile( fn + '.txt' ):
            file_state[ fn ] = STATE_CHECK_RAW
        return

    # check original file
    b, e = os.path.splitext( fn )
    if not e:
        return

    if e == '.yugen':
        # *.yugen --> *.yu
        origin = b + '.yu'  # or just b... (ignored)
    else:
        bb, be = os.path.splitext( b )
        if be == '.yugen':
            # *.yugen.* --> *.*
            origin = bb + e
        else:
            # *.* --> *.yu-*
            origin = b + '.yu-' + e[ 1: ]

    if os.path.isfile( origin ):
        file_state[ fn ] = STATE_NO_BROWSE
        file_jump[ fn ] = origin
        file_state[ origin ] = STATE_NO_BROWSE
        file_jump[ origin ] = fn
        return

#   ---------------------------------------------------------------------------
def close_file( fn ):
    if file_state[ fn ] == STATE_FRUIT:
        for x in file_data[ fn ][ 'paths' ]:
            file_state.pop( x, None )
            file_data.pop( x, None )
            file_jump.pop( x, None )

    elif file_state[ fn ] == STATE_NO_BROWSE:
        origin = file_jump[ fn ]
        file_state.pop( origin, None )
        file_jump.pop( origin, None )

    file_state.pop( fn, None )
    file_data.pop( fn, None )
    file_jump.pop( fn, None )
    file_mtime.pop( fn, None )

#   ---------------------------------------------------------------------------
class yu_browse( sublime_plugin.EventListener ):

#   -----------------------------------
    def on_load( self, view ):
        fn = view.file_name()
        if not fn:
            return

        # readonly
        view.set_read_only( not os.access( fn, os.W_OK ))

        if fn in file_state:
            # someone counts on me...
            if file_state[ fn ] == STATE_ORIGIN:
                if fn in file_jump:
                    # workaround: show_at_center() does not work from goto() if file has not been opened
                    view.show_at_center( sublime.Region( min( file_jump[ fn ].keys())))
            return

        open_file( fn )

#   -----------------------------------
    def on_close( self, view ):
        fn = view.file_name()
        if fn not in file_state:
            # ignore file
            return

        close_file( fn )

#   -----------------------------------
#   on_reload()
    def on_activated( self, view ):
        fn = view.file_name()
        if fn not in file_mtime:
            # ignore file
            return

        if file_mtime[ fn ] != os.path.getmtime( fn ):
            close_file( fn )
            open_file( fn )

#   ---------------------------------------------------------------------------
class GotoOriginCommand( sublime_plugin.TextCommand ):

#   -----------------------------------
    def goto( self, fn, pos ):
        view = self.view.window().open_file( fn )
        reg = sublime.Region( pos )
        view.sel().clear()
        view.sel().add( reg )
        view.show_at_center( reg )
        # workaround: caret position not refreshing if new position on the same line
        view.add_regions( 'bug', [ reg ], 'bug', 'dot', sublime.HIDDEN | sublime.PERSISTENT )
        view.erase_regions( 'bug' )

#   -----------------------------------
    def run( self, edit ):
        fn = self.view.file_name()
        if fn not in file_state:
            # ignore file
            return

        state = file_state[ fn ]
        if state == STATE_NO_BROWSE:
            self.view.window().open_file( file_jump[ fn ])

        else:
            pos = self.view.sel()[ 0 ].begin()
            if fn in file_jump:
                if pos in file_jump[ fn ]:
                    fn_to, pos_to = file_jump[ fn ][ pos ]
                    # jump to origin or back to fruit
                    self.goto( fn_to, pos_to )
                    return

            if state == STATE_FRUIT or state == STATE_CHECK_RAW:
                browse = file_data[ fn ][ 'browse' ]
                offset = file_data[ fn ][ 'offset' ]

                # search for position delta
                i = _bisect( offset, pos )
                delta = offset[ i - 1 ][ 1 ] if i else 0

                if state == STATE_CHECK_RAW:
                    fn_to = fn + '.txt'
                    file_state[ fn_to ] = STATE_ORIGIN
                    file_jump[ fn_to ] = { pos + delta: ( fn, pos )}
                    self.goto( fn_to, pos + delta )
                    return

                fn_fruit = fn
                pos_fruit = pos

                # search currect position in browse
                i = _bisect( browse, pos_fruit + delta )
                if i == 0:
                    return

                i -= 1
                pos_found, inx, pos_to = browse[ i ]
                dirs = self.view.window().folders()
                # search for original file in project directories
                fn_to = search_file( fn_fruit, dirs, inx )
                if ( i > 0 ) and ( browse[ i - 1 ][ 0 ] != pos_found ) and ( pos_to > 0 ):
                    # relative shift only in case of single jump
                    # and if origin is not ($macro)
                    pos_to += ( pos_fruit + delta - pos_found )

                pos_to = abs( pos_to )
                file_jump[ fn_fruit ] = {}
                file_jump[ fn_to ] = {}
                if fn_to:
                    # jump back to fruit
                    file_state[ fn_to ] = STATE_ORIGIN
                    file_jump[ fn_to ][ pos_to ] = ( fn_fruit, pos_fruit )
                    fn = fn_to
                    pos = pos_to
                i -= 1
                while i >= 0:
                    pos_from, inx, pos_to = browse[ i ]
                    pos_to = abs( pos_to )

                    if pos_from != pos_found:
                        break

                    fn_to = search_file( fn_fruit, dirs, inx )
                    if fn_to:
                        # previous jump to origin
                        file_state[ fn_to ] = STATE_ORIGIN
                        if fn_to not in file_jump:
                            file_jump[ fn_to ] = {}
                        file_jump[ fn_to ][ pos_to ] = ( fn, pos )
                        fn = fn_to
                        pos = pos_to
                    i -= 1

                # first jump to origin
                file_jump[ fn_fruit ][ pos_fruit ] = ( fn, pos )
                self.goto( fn, pos )

#   ---------------------------------------------------------------------------
# class CursorPositionInStatus( sublime_plugin.EventListener ):
#
#   -----------------------------------
#     def on_selection_modified( self, view ):
#         view.set_status( 'cursor_position'
#         , 'Pos ' + ', '.join( str( x.begin()) + ( '' if x.empty() else '-' + str( x.end())) for x in view.sel())
#         )
#
